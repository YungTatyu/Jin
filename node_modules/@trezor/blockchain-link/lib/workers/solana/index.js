"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = Solana;
const tslib_1 = require("tslib");
const errors_1 = require("@trezor/blockchain-link-types/lib/constants/errors");
const baseWorker_1 = require("../baseWorker");
const constants_1 = require("@trezor/blockchain-link-types/lib/constants");
const web3_js_1 = require("@solana/web3.js");
const blockchain_link_utils_1 = require("@trezor/blockchain-link-utils");
const utils_1 = require("@trezor/utils");
const solana_1 = require("@trezor/blockchain-link-utils/lib/solana");
const tokenUtils_1 = require("./tokenUtils");
const fee_1 = require("./fee");
const transactionConfirmation_1 = require("./transactionConfirmation");
const getAllSignatures = (api, descriptor) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    let lastSignature;
    let keepFetching = true;
    let allSignatures = [];
    const limit = 100;
    while (keepFetching) {
        const signaturesInfos = yield api.getSignaturesForAddress(new web3_js_1.PublicKey(descriptor), {
            before: lastSignature === null || lastSignature === void 0 ? void 0 : lastSignature.signature,
            limit,
        });
        const signatures = signaturesInfos.map(info => ({
            signature: info.signature,
            slot: info.slot,
        }));
        lastSignature = signatures[signatures.length - 1];
        keepFetching = signatures.length === limit;
        allSignatures = [...allSignatures, ...signatures];
    }
    return allSignatures;
});
const fetchTransactionPage = (api, signatures) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    const perChunk = 50;
    const confirmedSignatureChunks = signatures.reduce((resultArray, item, index) => {
        const chunkIndex = Math.floor(index / perChunk);
        if (!resultArray[chunkIndex]) {
            resultArray[chunkIndex] = [];
        }
        resultArray[chunkIndex].push(item);
        return resultArray;
    }, []);
    const confirmedTxsChunks = yield Promise.all(confirmedSignatureChunks.map(signatureChunk => api.getParsedTransactions(signatureChunk, {
        maxSupportedTransactionVersion: 0,
        commitment: 'confirmed',
    })));
    return confirmedTxsChunks.flat().filter((tx) => !!tx);
});
const isValidTransaction = (tx) => !!(tx && tx.meta && tx.transaction && tx.blockTime);
const pushTransaction = (request) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    const rawTx = request.payload.startsWith('0x') ? request.payload.slice(2) : request.payload;
    const api = yield request.connect();
    const { lastValidBlockHeight } = yield api.getLatestBlockhash('finalized');
    const txBuffer = Buffer.from(rawTx, 'hex');
    const signature = yield api.sendRawTransaction(txBuffer, {
        skipPreflight: true,
        maxRetries: 0,
    });
    yield (0, transactionConfirmation_1.confirmTransactionWithResubmit)(api, txBuffer, signature, lastValidBlockHeight);
    return {
        type: constants_1.RESPONSES.PUSH_TRANSACTION,
        payload: signature,
    };
});
const getAccountInfo = (request) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    const { payload } = request;
    const { details = 'basic' } = payload;
    const api = yield request.connect();
    const publicKey = new web3_js_1.PublicKey(payload.descriptor);
    const accountInfo = yield api.getAccountInfo(publicKey);
    const getTransactionPage = (txIds, tokenAccountsInfos) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
        const transactionsPage = yield fetchTransactionPage(api, txIds);
        const tokenMetadata = yield request.getTokenMetadata();
        return transactionsPage
            .filter(isValidTransaction)
            .map(tx => blockchain_link_utils_1.solanaUtils.transformTransaction(tx, payload.descriptor, tokenAccountsInfos, tokenMetadata))
            .filter((tx) => !!tx);
    });
    const tokenAccounts = yield api.getParsedTokenAccountsByOwner(publicKey, {
        programId: new web3_js_1.PublicKey(solana_1.TOKEN_PROGRAM_PUBLIC_KEY),
    });
    const allAccounts = [payload.descriptor, ...tokenAccounts.value.map(a => a.pubkey.toString())];
    const allTxIds = Array.from(new Set((yield Promise.all(allAccounts.map(account => getAllSignatures(api, account))))
        .flat()
        .sort((a, b) => b.slot - a.slot)
        .map(it => it.signature)));
    const pageNumber = payload.page ? payload.page - 1 : 0;
    const pageSize = payload.pageSize || 5;
    const pageStartIndex = pageNumber * pageSize;
    const pageEndIndex = Math.min(pageStartIndex + pageSize, allTxIds.length);
    const txIdPage = allTxIds.slice(pageStartIndex, pageEndIndex);
    const tokenAccountsInfos = tokenAccounts.value.map(a => {
        var _a, _b, _c, _d, _e;
        return ({
            address: a.pubkey.toString(),
            mint: (_b = (_a = a.account.data.parsed) === null || _a === void 0 ? void 0 : _a.info) === null || _b === void 0 ? void 0 : _b.mint,
            decimals: (_e = (_d = (_c = a.account.data.parsed) === null || _c === void 0 ? void 0 : _c.info) === null || _d === void 0 ? void 0 : _d.tokenAmount) === null || _e === void 0 ? void 0 : _e.decimals,
        });
    });
    const transactionPage = details === 'txs' ? yield getTransactionPage(txIdPage, tokenAccountsInfos) : undefined;
    let tokens = [];
    if (tokenAccounts.value.length > 0) {
        const tokenMetadata = yield request.getTokenMetadata();
        tokens = (0, solana_1.transformTokenInfo)(tokenAccounts.value, tokenMetadata);
    }
    const balance = yield api.getBalance(publicKey);
    const rent = yield api.getMinimumBalanceForRentExemption((accountInfo === null || accountInfo === void 0 ? void 0 : accountInfo.data.byteLength) || 0);
    const account = Object.assign({ descriptor: payload.descriptor, balance: balance.toString(), availableBalance: balance.toString(), empty: !allTxIds.length, history: {
            total: allTxIds.length,
            unconfirmed: 0,
            transactions: transactionPage,
            txids: txIdPage,
        }, page: transactionPage
            ? {
                total: allTxIds.length,
                index: pageNumber,
                size: transactionPage.length,
            }
            : undefined, tokens }, (accountInfo != null
        ? {
            misc: {
                owner: accountInfo.owner.toString(),
                rent,
            },
        }
        : {}));
    const workerAccount = request.state.getAccount(payload.descriptor);
    if (workerAccount) {
        request.state.addAccounts([Object.assign(Object.assign({}, workerAccount), { tokens })]);
    }
    return {
        type: constants_1.RESPONSES.GET_ACCOUNT_INFO,
        payload: account,
    };
});
const getInfo = (request) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    const api = yield request.connect();
    const { blockhash: blockHash, lastValidBlockHeight: blockHeight } = yield api.getLatestBlockhash('finalized');
    const isTestnet = (yield api.getGenesisHash()) !== '5eykt4UsFv8P8NJdTREpY1vzqKqZKvdpKuc147dw2N9d';
    const serverInfo = {
        testnet: isTestnet,
        blockHeight,
        blockHash,
        shortcut: isTestnet ? 'dsol' : 'sol',
        url: api.rpcEndpoint,
        name: 'Solana',
        version: (yield api.getVersion())['solana-core'],
        decimals: 9,
    };
    return {
        type: constants_1.RESPONSES.GET_INFO,
        payload: Object.assign({}, serverInfo),
    };
});
const estimateFee = (request) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    var _a, _b;
    const api = yield request.connect();
    const messageHex = (_a = request.payload.specific) === null || _a === void 0 ? void 0 : _a.data;
    const isCreatingAccount = (_b = request.payload.specific) === null || _b === void 0 ? void 0 : _b.isCreatingAccount;
    if (messageHex == null) {
        throw new Error('Could not estimate fee for transaction.');
    }
    const message = web3_js_1.Message.from(Buffer.from(messageHex, 'hex'));
    const baseFee = yield (0, fee_1.getBaseFee)(api, message);
    const priorityFee = yield (0, fee_1.getPriorityFee)(api, message);
    const accountCreationFee = isCreatingAccount
        ? yield api.getMinimumBalanceForRentExemption(tokenUtils_1.TOKEN_ACCOUNT_LAYOUT.span)
        : 0;
    const payload = [
        {
            feePerTx: `${baseFee + accountCreationFee + priorityFee.fee}`,
            feePerUnit: `${priorityFee.computeUnitPrice}`,
            feeLimit: `${priorityFee.computeUnitLimit}`,
        },
    ];
    return {
        type: constants_1.RESPONSES.ESTIMATE_FEE,
        payload,
    };
});
const BLOCK_SUBSCRIBE_INTERVAL_MS = 10000;
const subscribeBlock = (_a) => tslib_1.__awaiter(void 0, [_a], void 0, function* ({ state, connect, post }) {
    if (state.getSubscription('block'))
        return { subscribed: true };
    const api = yield connect();
    const interval = setInterval(() => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
        const { blockhash: blockHash, lastValidBlockHeight: blockHeight } = yield api.getLatestBlockhash('finalized');
        if (blockHeight) {
            post({
                id: -1,
                type: constants_1.RESPONSES.NOTIFICATION,
                payload: {
                    type: 'block',
                    payload: {
                        blockHeight,
                        blockHash,
                    },
                },
            });
        }
    }), BLOCK_SUBSCRIBE_INTERVAL_MS);
    state.addSubscription('block', interval);
    return { subscribed: true };
});
const unsubscribeBlock = ({ state }) => {
    if (!state.getSubscription('block'))
        return;
    const interval = state.getSubscription('block');
    clearInterval(interval);
    state.removeSubscription('block');
};
const extractTokenAccounts = (accounts) => accounts
    .map(account => {
    var _a;
    return (((_a = account.tokens) === null || _a === void 0 ? void 0 : _a.map(token => {
        var _a;
        return ((_a = token.accounts) === null || _a === void 0 ? void 0 : _a.map(tokenAccount => ({
            descriptor: tokenAccount.publicKey.toString(),
        }))) || [];
    })) || []).flat();
})
    .flat();
const findTokenAccountOwner = (accounts, accountDescriptor) => accounts.find(account => {
    var _a;
    return (_a = account.tokens) === null || _a === void 0 ? void 0 : _a.find(token => {
        var _a;
        return (_a = token.accounts) === null || _a === void 0 ? void 0 : _a.find(tokenAccount => tokenAccount.publicKey.toString() === accountDescriptor);
    });
});
const subscribeAccounts = (_a, accounts_1) => tslib_1.__awaiter(void 0, [_a, accounts_1], void 0, function* ({ connect, state, post, getTokenMetadata }, accounts) {
    const api = yield connect();
    const subscribedAccounts = state.getAccounts();
    const tokenAccounts = extractTokenAccounts(accounts);
    const newAccounts = [...accounts, ...tokenAccounts].filter(account => !subscribedAccounts.some(subscribedAccount => account.descriptor === subscribedAccount.descriptor));
    newAccounts.forEach(a => {
        const subscriptionId = api.onAccountChange(new web3_js_1.PublicKey(a.descriptor), () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            var _a, _b;
            const lastSignature = (_a = (yield api.getSignaturesForAddress(new web3_js_1.PublicKey(a.descriptor), {
                before: undefined,
                limit: 1,
            }))[0]) === null || _a === void 0 ? void 0 : _a.signature;
            if (!lastSignature)
                return;
            const lastTx = (yield api.getParsedTransactions([lastSignature], {
                maxSupportedTransactionVersion: 0,
                commitment: 'finalized',
            }))[0];
            if (!lastTx || !isValidTransaction(lastTx)) {
                return;
            }
            const tokenMetadata = yield getTokenMetadata();
            const tx = blockchain_link_utils_1.solanaUtils.transformTransaction(lastTx, a.descriptor, [], tokenMetadata);
            const descriptor = ((_b = findTokenAccountOwner(state.getAccounts(), a.descriptor)) === null || _b === void 0 ? void 0 : _b.descriptor) ||
                a.descriptor;
            post({
                id: -1,
                type: constants_1.RESPONSES.NOTIFICATION,
                payload: {
                    type: 'notification',
                    payload: {
                        descriptor,
                        tx,
                    },
                },
            });
        }));
        state.addAccounts([Object.assign(Object.assign({}, a), { subscriptionId })]);
    });
    return { subscribed: newAccounts.length > 0 };
});
const unsubscribeAccounts = (_a, ...args_1) => tslib_1.__awaiter(void 0, [_a, ...args_1], void 0, function* ({ state, connect }, accounts = []) {
    const api = yield connect();
    const subscribedAccounts = state.getAccounts();
    accounts.forEach(a => {
        var _a;
        if (a.subscriptionId) {
            api.removeAccountChangeListener(a.subscriptionId);
            state.removeAccounts([a]);
        }
        (_a = a.tokens) === null || _a === void 0 ? void 0 : _a.forEach(t => {
            var _a;
            (_a = t.accounts) === null || _a === void 0 ? void 0 : _a.forEach(ta => {
                const tokenAccount = subscribedAccounts.find(sa => sa.descriptor === ta.publicKey.toString());
                if (tokenAccount === null || tokenAccount === void 0 ? void 0 : tokenAccount.subscriptionId) {
                    api.removeAccountChangeListener(tokenAccount.subscriptionId);
                    state.removeAccounts([tokenAccount]);
                }
            });
        });
    });
});
const subscribe = (request) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    let response;
    switch (request.payload.type) {
        case 'block':
            response = yield subscribeBlock(request);
            break;
        case 'accounts':
            response = yield subscribeAccounts(request, request.payload.accounts);
            break;
        default:
            throw new errors_1.CustomError('worker_unknown_request', `+${request.type}`);
    }
    return {
        type: constants_1.RESPONSES.SUBSCRIBE,
        payload: response,
    };
});
const unsubscribe = (request) => {
    switch (request.payload.type) {
        case 'block':
            unsubscribeBlock(request);
            break;
        case 'accounts': {
            unsubscribeAccounts(request, request.payload.accounts);
            break;
        }
        default:
            throw new errors_1.CustomError('worker_unknown_request', `+${request.type}`);
    }
    return {
        type: constants_1.RESPONSES.UNSUBSCRIBE,
        payload: { subscribed: request.state.getAccounts().length > 0 },
    };
};
const onRequest = (request) => {
    switch (request.type) {
        case constants_1.MESSAGES.GET_ACCOUNT_INFO:
            return getAccountInfo(request);
        case constants_1.MESSAGES.GET_INFO:
            return getInfo(request);
        case constants_1.MESSAGES.PUSH_TRANSACTION:
            return pushTransaction(request);
        case constants_1.MESSAGES.ESTIMATE_FEE:
            return estimateFee(request);
        case constants_1.MESSAGES.SUBSCRIBE:
            return subscribe(request);
        case constants_1.MESSAGES.UNSUBSCRIBE:
            return unsubscribe(request);
        default:
            throw new errors_1.CustomError('worker_unknown_request', `+${request.type}`);
    }
};
class SolanaWorker extends baseWorker_1.BaseWorker {
    constructor() {
        super(...arguments);
        this.lazyTokens = (0, utils_1.createLazy)(() => blockchain_link_utils_1.solanaUtils.getTokenMetadata());
    }
    isConnected(api) {
        return !!api;
    }
    tryConnect(url) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const api = new web3_js_1.Connection(url, { wsEndpoint: url.replace('https', 'wss') });
            yield api.getLatestBlockhash('finalized');
            this.post({ id: -1, type: constants_1.RESPONSES.CONNECTED });
            return Promise.resolve(api);
        });
    }
    messageHandler(event) {
        const _super = Object.create(null, {
            messageHandler: { get: () => super.messageHandler }
        });
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            try {
                if (yield _super.messageHandler.call(this, event))
                    return true;
                const request = Object.assign(Object.assign({}, event.data), { connect: () => this.connect(), post: (data) => this.post(data), state: this.state, getTokenMetadata: this.lazyTokens.getOrInit });
                const response = yield onRequest(request);
                this.post(Object.assign({ id: event.data.id }, response));
            }
            catch (error) {
                this.errorResponse(event.data.id, error);
            }
        });
    }
    disconnect() {
        if (!this.api) {
            return;
        }
        this.state
            .getAccounts()
            .forEach(a => { var _a; return a.subscriptionId && ((_a = this.api) === null || _a === void 0 ? void 0 : _a.removeAccountChangeListener(a.subscriptionId)); });
        if (this.state.getSubscription('block')) {
            const interval = this.state.getSubscription('block');
            clearInterval(interval);
            this.state.removeSubscription('block');
        }
        this.api = undefined;
    }
}
function Solana() {
    return new SolanaWorker();
}
if (baseWorker_1.CONTEXT === 'worker') {
    const module = new SolanaWorker();
    onmessage = module.messageHandler.bind(module);
}
//# sourceMappingURL=index.js.map