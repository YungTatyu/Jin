"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.confirmTransactionWithResubmit = void 0;
const tslib_1 = require("tslib");
const COMMITMENT = 'finalized';
const tryConfirmBySignatureStatus = (api, txBuffer, signature, lastValidBlockHeight, abortSignal) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    const getCurrentBlockHeight = () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
        try {
            return yield api.getBlockHeight('finalized');
        }
        catch (_) {
            return -1;
        }
    });
    let currentBlockHeight = yield getCurrentBlockHeight();
    while (currentBlockHeight <= lastValidBlockHeight) {
        const signatureStatuses = yield api.getSignatureStatuses([signature]);
        if (signatureStatuses.value.length === 1 &&
            signatureStatuses.value[0] != null &&
            signatureStatuses.value[0].confirmationStatus === COMMITMENT) {
            return signature;
        }
        yield new Promise(resolve => setTimeout(resolve, 5000));
        if (abortSignal.aborted) {
            return signature;
        }
        yield api.sendRawTransaction(txBuffer, { skipPreflight: true, maxRetries: 0 });
        currentBlockHeight = yield getCurrentBlockHeight();
    }
    throw new Error(`TransactionExpiredBlockheightExceededError: Signature ${signature} has expired: block height exceeded.`);
});
const tryConfirmBySignatureSubscription = (api, signature) => {
    let subscriptionId;
    const confirmationPromise = new Promise((resolve, reject) => {
        subscriptionId = api.onSignature(signature, result => {
            if (result.err != null) {
                reject(result.err);
            }
            resolve(signature);
        }, COMMITMENT);
    });
    return { subscriptionId, confirmationPromise };
};
const confirmTransactionWithResubmit = (api, txBuffer, signature, lastValidBlockHeight) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    const { subscriptionId, confirmationPromise: signatureSubscriptionConfirmationPromise } = tryConfirmBySignatureSubscription(api, signature);
    const abortController = new AbortController();
    const signatureStatusConfirmationPromise = tryConfirmBySignatureStatus(api, txBuffer, signature, lastValidBlockHeight, abortController.signal);
    yield Promise.race([
        signatureSubscriptionConfirmationPromise,
        signatureStatusConfirmationPromise,
    ]);
    abortController.abort();
    if (subscriptionId != null) {
        api.removeSignatureListener(subscriptionId);
    }
    return signature;
});
exports.confirmTransactionWithResubmit = confirmTransactionWithResubmit;
//# sourceMappingURL=transactionConfirmation.js.map