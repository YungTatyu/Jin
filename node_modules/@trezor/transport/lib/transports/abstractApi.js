"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AbstractApiTransport = void 0;
const tslib_1 = require("tslib");
const utils_1 = require("@trezor/utils");
const protocol_1 = require("@trezor/protocol");
const abstract_1 = require("./abstract");
const send_1 = require("../utils/send");
const receive_1 = require("../utils/receive");
const ERRORS = tslib_1.__importStar(require("../errors"));
class AbstractApiTransport extends abstract_1.AbstractTransport {
    constructor({ messages, api, sessionsClient, logger }) {
        super({ messages, logger });
        this.sessionsClient = sessionsClient;
        this.api = api;
    }
    init({ signal } = {}) {
        return this.scheduleAction(() => tslib_1.__awaiter(this, void 0, void 0, function* () {
            const handshakeRes = yield this.sessionsClient.handshake();
            this.stopped = !handshakeRes.success;
            return handshakeRes.success
                ? this.success(undefined)
                : this.unknownError('handshake error');
        }), { signal });
    }
    listen() {
        if (this.listening) {
            return this.error({ error: ERRORS.ALREADY_LISTENING });
        }
        this.listening = true;
        this.api.on('transport-interface-change', descriptors => {
            var _a;
            (_a = this === null || this === void 0 ? void 0 : this.logger) === null || _a === void 0 ? void 0 : _a.debug('new descriptors from api', descriptors);
            this.sessionsClient.enumerateDone({
                descriptors,
            });
        });
        this.sessionsClient.on('descriptors', descriptors => {
            var _a;
            (_a = this === null || this === void 0 ? void 0 : this.logger) === null || _a === void 0 ? void 0 : _a.debug('new descriptors from background', descriptors);
            this.handleDescriptorsChange(descriptors);
        });
        return this.success(undefined);
    }
    enumerate({ signal } = {}) {
        return this.scheduleAction((signal) => tslib_1.__awaiter(this, void 0, void 0, function* () {
            const enumerateResult = yield this.api.enumerate(signal);
            if (!enumerateResult.success) {
                return enumerateResult;
            }
            const descriptors = enumerateResult.payload;
            const enumerateDoneResponse = yield this.sessionsClient.enumerateDone({
                descriptors,
            });
            return this.success(enumerateDoneResponse.payload.descriptors);
        }), { signal });
    }
    acquire({ input, signal }) {
        return this.scheduleAction((signal) => tslib_1.__awaiter(this, void 0, void 0, function* () {
            const { path } = input;
            if (this.listening) {
                this.listenPromise[path] = (0, utils_1.createDeferred)();
            }
            const acquireIntentResponse = yield this.sessionsClient.acquireIntent(input);
            if (!acquireIntentResponse.success) {
                return this.error({ error: acquireIntentResponse.error });
            }
            this.acquiredUnconfirmed[path] = acquireIntentResponse.payload.session;
            const reset = !!input.previous;
            const openDeviceResult = yield this.api.openDevice(acquireIntentResponse.payload.path, reset, signal);
            if (!openDeviceResult.success) {
                if (this.listenPromise[path]) {
                    this.listenPromise[path].resolve(openDeviceResult);
                }
                return openDeviceResult;
            }
            this.sessionsClient.acquireDone({ path });
            if (!this.listenPromise[path]) {
                return this.success(acquireIntentResponse.payload.session);
            }
            return this.listenPromise[path].promise.finally(() => {
                delete this.listenPromise[path];
            });
        }), { signal }, [ERRORS.DEVICE_DISCONNECTED_DURING_ACTION, ERRORS.SESSION_WRONG_PREVIOUS]);
    }
    release({ path, session, onClose, signal }) {
        return this.scheduleAction(() => tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (this.listening) {
                this.releaseUnconfirmed[path] = session;
                this.listenPromise[path] = (0, utils_1.createDeferred)();
            }
            const releaseIntentResponse = yield this.sessionsClient.releaseIntent({
                session,
            });
            if (!releaseIntentResponse.success) {
                return this.error({ error: releaseIntentResponse.error });
            }
            const releasePromise = this.releaseDevice(releaseIntentResponse.payload.path);
            if (onClose)
                return this.success(undefined);
            yield releasePromise;
            yield this.sessionsClient.releaseDone({
                path: releaseIntentResponse.payload.path,
            });
            if (!this.listenPromise[path]) {
                return this.success(undefined);
            }
            return this.listenPromise[path].promise
                .then(() => this.success(undefined))
                .finally(() => {
                delete this.listenPromise[path];
            });
        }), { signal });
    }
    call({ session, name, data, protocol: customProtocol, signal, }) {
        return this.scheduleAction((signal) => tslib_1.__awaiter(this, void 0, void 0, function* () {
            const handleError = (error) => {
                if (error === ERRORS.DEVICE_DISCONNECTED_DURING_ACTION) {
                    this.enumerate();
                }
            };
            const getPathBySessionResponse = yield this.sessionsClient.getPathBySession({
                session,
            });
            if (!getPathBySessionResponse.success) {
                if (getPathBySessionResponse.error === 'session not found') {
                    return this.error({ error: ERRORS.DEVICE_DISCONNECTED_DURING_ACTION });
                }
                return this.error({ error: ERRORS.UNEXPECTED_ERROR });
            }
            const { path } = getPathBySessionResponse.payload;
            const protocol = customProtocol || protocol_1.v1;
            const bytes = (0, send_1.buildMessage)({
                messages: this.messages,
                name,
                data,
                encode: protocol.encode,
            });
            const chunks = (0, send_1.createChunks)(bytes, protocol.getChunkHeader(bytes), this.api.chunkSize);
            const apiWrite = (chunk) => this.api.write(path, chunk, signal);
            const sendResult = yield (0, send_1.sendChunks)(chunks, apiWrite);
            if (!sendResult.success) {
                handleError(sendResult.error);
                return sendResult;
            }
            const readResult = yield (0, receive_1.receiveAndParse)(this.messages, () => this.api.read(path, signal), protocol);
            if (!readResult.success) {
                handleError(readResult.error);
                return readResult;
            }
            return readResult;
        }), { signal, timeout: undefined });
    }
    send({ data, session, name, protocol, signal }) {
        return this.scheduleAction((signal) => tslib_1.__awaiter(this, void 0, void 0, function* () {
            const getPathBySessionResponse = yield this.sessionsClient.getPathBySession({
                session,
            });
            if (!getPathBySessionResponse.success) {
                return this.error({ error: getPathBySessionResponse.error });
            }
            const { path } = getPathBySessionResponse.payload;
            const { encode, getChunkHeader } = protocol || protocol_1.v1;
            const bytes = (0, send_1.buildMessage)({
                messages: this.messages,
                name,
                data,
                encode,
            });
            const chunks = (0, send_1.createChunks)(bytes, getChunkHeader(bytes), this.api.chunkSize);
            const apiWrite = (chunk) => this.api.write(path, chunk, signal);
            const sendResult = yield (0, send_1.sendChunks)(chunks, apiWrite);
            if (!sendResult.success) {
                if (sendResult.error === ERRORS.DEVICE_DISCONNECTED_DURING_ACTION) {
                    this.enumerate();
                }
            }
            return sendResult;
        }), { signal, timeout: undefined });
    }
    receive({ session, protocol: customProtocol, signal, }) {
        return this.scheduleAction((signal) => tslib_1.__awaiter(this, void 0, void 0, function* () {
            const getPathBySessionResponse = yield this.sessionsClient.getPathBySession({
                session,
            });
            if (!getPathBySessionResponse.success) {
                return this.error({ error: getPathBySessionResponse.error });
            }
            const { path } = getPathBySessionResponse.payload;
            const protocol = customProtocol || protocol_1.v1;
            const message = yield (0, receive_1.receiveAndParse)(this.messages, () => this.api.read(path, signal), protocol);
            if (!message.success) {
                console.log(message.error);
                if (message.error === ERRORS.DEVICE_DISCONNECTED_DURING_ACTION) {
                    this.enumerate();
                }
            }
            return message;
        }), { signal, timeout: undefined });
    }
    releaseDevice(path) {
        return this.api.closeDevice(path);
    }
    stop() {
        super.stop();
        this.api.on('transport-interface-change', () => {
            var _a;
            (_a = this.logger) === null || _a === void 0 ? void 0 : _a.debug('device connected after transport stopped');
        });
    }
}
exports.AbstractApiTransport = AbstractApiTransport;
//# sourceMappingURL=abstractApi.js.map