import * as protobuf from 'protobufjs/light';
import { ScheduleActionParams, ScheduledAction, Deferred } from '@trezor/utils';
import { TypedEmitter } from '@trezor/utils';
import { PROTOCOL_MALFORMED, TransportProtocol } from '@trezor/protocol';
import { MessageFromTrezor } from '@trezor/protobuf';
import { Session, Descriptor, AbortableParam, AsyncResultWithTypedError, ResultWithTypedError, Success, AnyError, Logger, PathPublic } from '../types';
import * as ERRORS from '../errors';
import { TRANSPORT } from '../constants';
export type AcquireInput = {
    path: PathPublic;
    previous: Session | null;
};
export type ReleaseInput = {
    path: PathPublic;
    session: Session;
    onClose?: boolean;
};
type DescriptorDiffItem = {
    descriptor: Descriptor;
} & ({
    type: 'connected' | 'disconnected';
} | {
    type: 'acquired' | 'released';
    subtype: 'here' | 'elsewhere';
});
export type DeviceDescriptorDiff = DescriptorDiffItem[];
export interface AbstractTransportParams {
    messages?: Record<string, any>;
    logger?: Logger;
    debugLink?: boolean;
}
export declare const isTransportInstance: (transport?: AbstractTransport) => boolean;
type ReadWriteError = typeof ERRORS.HTTP_ERROR | typeof ERRORS.WRONG_RESULT_TYPE | typeof ERRORS.OTHER_CALL_IN_PROGRESS | typeof PROTOCOL_MALFORMED | typeof ERRORS.DEVICE_DISCONNECTED_DURING_ACTION | typeof ERRORS.UNEXPECTED_ERROR | typeof ERRORS.SESSION_NOT_FOUND | typeof ERRORS.ABORTED_BY_TIMEOUT | typeof ERRORS.ABORTED_BY_SIGNAL | typeof ERRORS.WRONG_ENVIRONMENT | typeof ERRORS.DEVICE_NOT_FOUND | typeof ERRORS.INTERFACE_UNABLE_TO_OPEN_DEVICE | typeof ERRORS.INTERFACE_DATA_TRANSFER;
declare class TransportEmitter extends TypedEmitter<{
    [TRANSPORT.UPDATE]: DeviceDescriptorDiff;
    [TRANSPORT.ERROR]: typeof ERRORS.HTTP_ERROR | typeof ERRORS.WRONG_RESULT_TYPE | typeof ERRORS.UNEXPECTED_ERROR;
}> {
}
export declare abstract class AbstractTransport extends TransportEmitter {
    abstract name: 'BridgeTransport' | 'NodeUsbTransport' | 'WebUsbTransport' | 'UdpTransport';
    isOutdated: boolean;
    version: string;
    protected stopped: boolean;
    protected listening: boolean;
    protected messages: protobuf.Root;
    protected descriptors: Descriptor[];
    protected acquiredUnconfirmed: Record<string, Session>;
    protected listenPromise: Record<string, Deferred<ResultWithTypedError<Session, typeof ERRORS.DEVICE_DISCONNECTED_DURING_ACTION | typeof ERRORS.SESSION_WRONG_PREVIOUS | typeof ERRORS.DEVICE_NOT_FOUND | typeof ERRORS.INTERFACE_UNABLE_TO_OPEN_DEVICE | typeof ERRORS.UNEXPECTED_ERROR | typeof ERRORS.ABORTED_BY_TIMEOUT | typeof ERRORS.ABORTED_BY_SIGNAL>>>;
    protected releasePromise?: Deferred<any>;
    protected releaseUnconfirmed: Record<string, Session>;
    protected abortController: AbortController;
    protected logger?: Logger;
    constructor({ messages, logger }: AbstractTransportParams);
    abstract init(params?: AbortableParam): AsyncResultWithTypedError<undefined, typeof ERRORS.SESSION_BACKGROUND_TIMEOUT | typeof ERRORS.WRONG_ENVIRONMENT | typeof ERRORS.WRONG_RESULT_TYPE | typeof ERRORS.HTTP_ERROR | typeof ERRORS.UNEXPECTED_ERROR | typeof ERRORS.ABORTED_BY_TIMEOUT | typeof ERRORS.ABORTED_BY_SIGNAL>;
    abstract listen(): ResultWithTypedError<undefined, typeof ERRORS.ALREADY_LISTENING | typeof ERRORS.WRONG_ENVIRONMENT>;
    abstract enumerate(params?: AbortableParam): AsyncResultWithTypedError<Descriptor[], typeof ERRORS.HTTP_ERROR | typeof ERRORS.WRONG_RESULT_TYPE | typeof ERRORS.ABORTED_BY_TIMEOUT | typeof ERRORS.ABORTED_BY_SIGNAL | typeof ERRORS.UNEXPECTED_ERROR | typeof ERRORS.WRONG_ENVIRONMENT>;
    abstract acquire(params: {
        input: AcquireInput;
    } & AbortableParam): AsyncResultWithTypedError<Session, typeof ERRORS.INTERFACE_UNABLE_TO_OPEN_DEVICE | typeof ERRORS.DESCRIPTOR_NOT_FOUND | typeof ERRORS.WRONG_RESULT_TYPE | typeof ERRORS.HTTP_ERROR | typeof ERRORS.DEVICE_DISCONNECTED_DURING_ACTION | typeof ERRORS.DEVICE_NOT_FOUND | typeof ERRORS.SESSION_WRONG_PREVIOUS | typeof ERRORS.UNEXPECTED_ERROR | typeof ERRORS.ABORTED_BY_TIMEOUT | typeof ERRORS.ABORTED_BY_SIGNAL | typeof ERRORS.WRONG_ENVIRONMENT>;
    abstract release(params: ReleaseInput & AbortableParam): AsyncResultWithTypedError<void, typeof ERRORS.SESSION_NOT_FOUND | typeof ERRORS.HTTP_ERROR | typeof ERRORS.WRONG_RESULT_TYPE | typeof ERRORS.DEVICE_DISCONNECTED_DURING_ACTION | typeof ERRORS.SESSION_WRONG_PREVIOUS | typeof ERRORS.DEVICE_NOT_FOUND | typeof ERRORS.INTERFACE_UNABLE_TO_OPEN_DEVICE | typeof ERRORS.UNEXPECTED_ERROR | typeof ERRORS.ABORTED_BY_TIMEOUT | typeof ERRORS.ABORTED_BY_SIGNAL | typeof ERRORS.WRONG_ENVIRONMENT>;
    abstract releaseDevice(path: string): AsyncResultWithTypedError<void, string>;
    abstract send(params: {
        path?: string;
        session: Session;
        name: string;
        data: Record<string, unknown>;
        protocol?: TransportProtocol;
    } & AbortableParam): AsyncResultWithTypedError<undefined, ReadWriteError>;
    abstract receive(params: {
        path?: string;
        session: Session;
        protocol?: TransportProtocol;
    } & AbortableParam): AsyncResultWithTypedError<MessageFromTrezor, ReadWriteError>;
    abstract call(params: {
        session: Session;
        name: string;
        data: Record<string, unknown>;
        protocol?: TransportProtocol;
    } & AbortableParam): AsyncResultWithTypedError<MessageFromTrezor, ReadWriteError>;
    stop(): void;
    private getDiff;
    handleDescriptorsChange(nextDescriptors: Descriptor[]): void;
    getMessage(message?: string): boolean;
    updateMessages(messages: Record<string, any>): void;
    protected success<T>(payload: T): Success<T>;
    protected error<E extends AnyError>(payload: {
        error: E;
        message?: string;
    }): {
        success: false;
        error: E;
        message: string | undefined;
    };
    protected unknownError: <E extends AnyError = never>(err: Error | string, expectedErrors?: E[]) => {
        success: false;
        error: E;
        message: string | undefined;
    } | {
        success: false;
        error: "unexpected error";
        message: string;
    };
    private mergeAbort;
    protected scheduleAction: <T, E extends AnyError = never>(action: ScheduledAction<T>, params?: ScheduleActionParams, errors?: E[]) => Promise<T | {
        success: false;
        error: NonNullable<"Aborted by signal" | "Aborted by timeout" | E>;
        message: string | undefined;
    } | {
        success: false;
        error: "unexpected error";
        message: string;
    }>;
}
export type AbstractTransportMethodParams<K extends keyof AbstractTransport> = AbstractTransport[K] extends (...args: any[]) => any ? Parameters<AbstractTransport[K]>[0] : never;
export {};
//# sourceMappingURL=abstract.d.ts.map