"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Device = exports.GET_FEATURES_TIMEOUT_REACT_NATIVE = exports.GET_FEATURES_TIMEOUT = void 0;
const utils_1 = require("@trezor/utils");
const protocol_1 = require("@trezor/protocol");
const DeviceCommands_1 = require("./DeviceCommands");
const constants_1 = require("../constants");
const events_1 = require("../events");
const coinInfo_1 = require("../data/coinInfo");
const DataManager_1 = require("../data/DataManager");
const firmwareInfo_1 = require("../data/firmwareInfo");
const deviceFeaturesUtils_1 = require("../utils/deviceFeaturesUtils");
const debug_1 = require("../utils/debug");
const transport_1 = require("@trezor/transport");
const types_1 = require("../types");
const models_1 = require("../data/models");
const getLanguage_1 = require("../data/getLanguage");
const checkFirmwareRevision_1 = require("./checkFirmwareRevision");
const _log = (0, debug_1.initLog)('Device');
exports.GET_FEATURES_TIMEOUT = 3000;
exports.GET_FEATURES_TIMEOUT_REACT_NATIVE = 20000;
const parseRunOptions = (options) => {
    if (!options)
        options = {};
    return options;
};
class Device extends utils_1.TypedEmitter {
    constructor(transport, descriptor) {
        super();
        this.featuresNeedsReload = false;
        this.keepTransportSession = false;
        this.loaded = false;
        this.inconsistent = false;
        this.instance = 0;
        this.state = [];
        this.stateStorage = undefined;
        this.unavailableCapabilities = {};
        this.networkTypeState = [];
        this.name = 'Trezor';
        this.availableTranslations = [];
        this.authenticityChecks = {
            firmwareRevision: null,
        };
        this.useCardanoDerivation = false;
        this.protocol = protocol_1.v1;
        this.transport = transport;
        this.originalDescriptor = descriptor;
        this.firstRunPromise = (0, utils_1.createDeferred)();
    }
    static fromDescriptor(transport, originalDescriptor) {
        const descriptor = { ...originalDescriptor, session: null };
        try {
            const device = new Device(transport, descriptor);
            return device;
        }
        catch (error) {
            _log.error('Device.fromDescriptor', error);
            throw error;
        }
    }
    static createUnacquired(transport, descriptor, unreadableError) {
        const device = new Device(transport, descriptor);
        device.unreadableError = unreadableError;
        return device;
    }
    async acquire() {
        this.acquirePromise = this.transport.acquire({
            input: {
                path: this.originalDescriptor.path,
                previous: this.originalDescriptor.session,
            },
        });
        const acquireResult = await this.acquirePromise;
        this.acquirePromise = undefined;
        if (!acquireResult.success) {
            if (this.runPromise) {
                this.runPromise.reject(new Error(acquireResult.error));
                delete this.runPromise;
            }
            throw acquireResult.error;
        }
        const transportSession = acquireResult.payload;
        _log.debug('Expected workflow id:', transportSession);
        this.transportSession = transportSession;
        this.originalDescriptor.session = transportSession;
        if (this.commands) {
            this.commands.dispose();
        }
        this.commands = new DeviceCommands_1.DeviceCommands(this, this.transport, transportSession);
    }
    async release() {
        if (this.isUsedHere() &&
            this.transportSession &&
            !this.keepTransportSession &&
            !this.releasePromise) {
            if (this.commands) {
                this.commands.dispose();
                if (this.commands.callPromise) {
                    await this.commands.callPromise;
                }
            }
            this.releasePromise = this.transport.release({
                session: this.transportSession,
                path: this.originalDescriptor.path,
            });
            const releaseResponse = await this.releasePromise;
            this.releasePromise = undefined;
            if (releaseResponse.success) {
                this.transportSession = null;
                this.originalDescriptor.session = null;
            }
        }
    }
    async cleanup() {
        const acquiredListeners = this.listeners(events_1.DEVICE.ACQUIRED);
        this.removeAllListeners();
        delete this.runPromise;
        await this.release();
        acquiredListeners.forEach(l => this.once(events_1.DEVICE.ACQUIRED, l));
    }
    run(fn, options) {
        if (this.runPromise) {
            _log.warn('Previous call is still running');
            throw constants_1.ERRORS.TypedError('Device_CallInProgress');
        }
        options = parseRunOptions(options);
        const runPromise = (0, utils_1.createDeferred)();
        this.runPromise = runPromise;
        this._runInner(fn, options).catch(err => {
            runPromise.reject(err);
        });
        return runPromise.promise;
    }
    async override(error) {
        if (this.acquirePromise) {
            await this.acquirePromise;
        }
        if (this.runPromise) {
            await this.interruptionFromUser(error);
        }
        if (this.releasePromise) {
            await this.releasePromise;
        }
    }
    async interruptionFromUser(error) {
        _log.debug('interruptionFromUser');
        if (this.runPromise) {
            this.runPromise.reject(error);
            delete this.runPromise;
        }
        if (this.commands) {
            await this.commands.cancel();
        }
    }
    interruptionFromOutside() {
        _log.debug('interruptionFromOutside');
        if (this.commands) {
            this.commands.dispose();
        }
        if (this.runPromise) {
            this.runPromise.reject(constants_1.ERRORS.TypedError('Device_UsedElsewhere'));
            delete this.runPromise;
        }
        this.transport.releaseDevice(this.originalDescriptor.path);
    }
    async _runInner(fn, options) {
        var _a, _b;
        if (this.releasePromise) {
            await this.releasePromise;
        }
        if (!this.isUsedHere() ||
            ((_a = this.commands) === null || _a === void 0 ? void 0 : _a.disposed) ||
            !((_b = this.getState()) === null || _b === void 0 ? void 0 : _b.staticSessionId) ||
            this.useCardanoDerivation != !!options.useCardanoDerivation) {
            await this.acquire();
            try {
                if (fn) {
                    await this.initialize(!!options.useCardanoDerivation);
                }
                else {
                    const getFeaturesTimeout = DataManager_1.DataManager.getSettings('env') === 'react-native'
                        ? exports.GET_FEATURES_TIMEOUT_REACT_NATIVE
                        : exports.GET_FEATURES_TIMEOUT;
                    await Promise.race([
                        this.getFeatures(),
                        new Promise((_resolve, reject) => setTimeout(() => reject(new Error('GetFeatures timeout')), getFeaturesTimeout)),
                    ]);
                }
            }
            catch (error) {
                if (!this.inconsistent &&
                    (error.message === 'GetFeatures timeout' || error.message === 'Unknown message')) {
                    this.inconsistent = true;
                    return this._runInner(() => Promise.resolve({}), options);
                }
                if (transport_1.TRANSPORT_ERROR.ABORTED_BY_TIMEOUT === error.message) {
                    this.unreadableError = 'Connection timeout';
                }
                this.inconsistent = true;
                delete this.runPromise;
                return Promise.reject(constants_1.ERRORS.TypedError('Device_InitializeFailed', `Initialize failed: ${error.message}${error.code ? `, code: ${error.code}` : ''}`));
            }
        }
        if (options.keepSession) {
            this.keepTransportSession = true;
        }
        if (this.listeners(events_1.DEVICE.ACQUIRED).length > 0) {
            this.emit(events_1.DEVICE.ACQUIRED);
        }
        if (fn) {
            await fn();
        }
        if (this.loaded && this.features && !options.skipFinalReload) {
            await this.getFeatures();
        }
        if ((!this.keepTransportSession && typeof options.keepSession !== 'boolean') ||
            options.keepSession === false) {
            this.keepTransportSession = false;
            await this.release();
        }
        if (this.runPromise) {
            this.runPromise.resolve();
        }
        delete this.runPromise;
        if (!this.loaded) {
            this.loaded = true;
            this.firstRunPromise.resolve(true);
        }
    }
    getCommands() {
        if (!this.commands) {
            throw constants_1.ERRORS.TypedError('Runtime', `Device: commands not defined`);
        }
        return this.commands;
    }
    setInstance(instance = 0) {
        if (this.instance !== instance) {
            if (this.keepTransportSession) {
                this.transportSession = null;
                this.keepTransportSession = false;
            }
        }
        this.instance = instance;
    }
    getInstance() {
        return this.instance;
    }
    getState() {
        return this.state[this.instance];
    }
    setState(state) {
        var _a;
        if (!state) {
            delete this.state[this.instance];
        }
        else {
            const prevState = this.state[this.instance];
            const newState = {
                ...prevState,
                ...state,
            };
            this.state[this.instance] = newState;
            (_a = this.stateStorage) === null || _a === void 0 ? void 0 : _a.saveState(this, newState);
        }
    }
    async validateState(preauthorized = false) {
        var _a;
        if (!this.features)
            return;
        if (!this.features.unlocked && preauthorized) {
            if (await this.getCommands().preauthorize(false)) {
                return;
            }
        }
        const expectedState = (_a = this.getState()) === null || _a === void 0 ? void 0 : _a.staticSessionId;
        const state = await this.getCommands().getDeviceState();
        const uniqueState = `${state}@${this.features.device_id}:${this.instance}`;
        if (this.features.session_id) {
            this.setState({ sessionId: this.features.session_id });
        }
        if (expectedState && expectedState !== uniqueState) {
            return uniqueState;
        }
        if (!expectedState) {
            this.setState({ staticSessionId: uniqueState });
        }
    }
    async initialize(useCardanoDerivation) {
        var _a;
        let payload;
        if (this.features) {
            const sessionId = (_a = this.getState()) === null || _a === void 0 ? void 0 : _a.sessionId;
            payload = {};
            payload.derive_cardano = useCardanoDerivation;
            this.useCardanoDerivation = useCardanoDerivation;
            if (sessionId) {
                payload.session_id = sessionId;
            }
        }
        const { message } = await this.getCommands().typedCall('Initialize', 'Features', payload);
        this._updateFeatures(message);
    }
    initStorage(storage) {
        this.stateStorage = storage;
        this.setState(storage.loadState(this));
    }
    async getFeatures() {
        const { message } = await this.getCommands().typedCall('GetFeatures', 'Features', {});
        this._updateFeatures(message);
        if (this.authenticityChecks.firmwareRevision === null ||
            (this.authenticityChecks.firmwareRevision.success === false &&
                this.authenticityChecks.firmwareRevision.error === 'cannot-perform-check-offline')) {
            await this.checkFirmwareRevision();
        }
        if (!this.features.language_version_matches &&
            this.features.language &&
            this.atLeast('2.7.0')) {
            _log.info('language version mismatch. silently updating...');
            try {
                await this.changeLanguage({ language: this.features.language });
            }
            catch (err) {
                _log.error('change language failed silently', err);
            }
        }
    }
    async checkFirmwareRevision() {
        const firmwareVersion = this.getVersion();
        if (!firmwareVersion || !this.features) {
            return;
        }
        if (this.features.bootloader_mode === true) {
            return;
        }
        const releases = (0, firmwareInfo_1.getReleases)(this.features.internal_model);
        const release = releases.find(r => firmwareVersion &&
            utils_1.versionUtils.isVersionArray(firmwareVersion) &&
            utils_1.versionUtils.isEqual(r.version, firmwareVersion));
        this.authenticityChecks.firmwareRevision = await (0, checkFirmwareRevision_1.checkFirmwareRevision)({
            internalModel: this.features.internal_model,
            deviceRevision: this.features.revision,
            firmwareVersion,
            expectedRevision: release === null || release === void 0 ? void 0 : release.firmware_revision,
        });
    }
    async changeLanguage({ language, binary, }) {
        if (language === 'en-US') {
            return this._uploadTranslationData(null);
        }
        if (binary) {
            return this._uploadTranslationData(binary);
        }
        const version = this.getVersion();
        if (!version) {
            throw constants_1.ERRORS.TypedError('Runtime', 'changeLanguage: device version unknown');
        }
        const downloadedBinary = await (0, getLanguage_1.getLanguage)({
            language,
            version,
            internal_model: this.features.internal_model,
        });
        if (!downloadedBinary) {
            throw constants_1.ERRORS.TypedError('Runtime', 'changeLanguage: translation not found');
        }
        return this._uploadTranslationData(downloadedBinary);
    }
    async _uploadTranslationData(payload) {
        if (!this.commands) {
            throw constants_1.ERRORS.TypedError('Runtime', 'uploadTranslationData: device.commands is not set');
        }
        if (payload === null) {
            const response = await this.commands.typedCall('ChangeLanguage', ['Success'], { data_length: 0 });
            return response.message;
        }
        const length = payload.byteLength;
        let response = await this.commands.typedCall('ChangeLanguage', ['TranslationDataRequest', 'Success'], { data_length: length });
        while (response.type !== 'Success') {
            const start = response.message.data_offset;
            const end = response.message.data_offset + response.message.data_length;
            const chunk = payload.slice(start, end);
            response = await this.commands.typedCall('TranslationDataAck', ['TranslationDataRequest', 'Success'], {
                data_chunk: Buffer.from(chunk).toString('hex'),
            });
        }
        return response.message;
    }
    _updateFeatures(feat) {
        var _a, _b, _c, _d;
        const capabilities = (0, deviceFeaturesUtils_1.parseCapabilities)(feat);
        feat.capabilities = capabilities;
        if (this.features && this.features.session_id && !feat.session_id) {
            feat.session_id = this.features.session_id;
        }
        feat.unlocked = (_a = feat.unlocked) !== null && _a !== void 0 ? _a : true;
        const revision = (0, deviceFeaturesUtils_1.parseRevision)(feat);
        feat.revision = revision;
        if (!feat.model && feat.major_version === 1) {
            feat.model = '1';
        }
        if (!feat.internal_model) {
            feat.internal_model = (0, deviceFeaturesUtils_1.ensureInternalModelFeature)(feat.model);
        }
        const version = this.getVersion();
        const newVersion = [
            feat.major_version,
            feat.minor_version,
            feat.patch_version,
        ];
        if (!version || !utils_1.versionUtils.isEqual(version, newVersion)) {
            this.unavailableCapabilities = (0, deviceFeaturesUtils_1.getUnavailableCapabilities)(feat, (0, coinInfo_1.getAllNetworks)());
            this.firmwareStatus = (0, firmwareInfo_1.getFirmwareStatus)(feat);
            this.firmwareRelease = (0, firmwareInfo_1.getRelease)(feat);
            this.availableTranslations = (_c = (_b = this.firmwareRelease) === null || _b === void 0 ? void 0 : _b.translations) !== null && _c !== void 0 ? _c : [];
        }
        this.features = feat;
        this.featuresNeedsReload = false;
        if (feat.fw_vendor === 'Trezor Bitcoin-only') {
            this.firmwareType = types_1.FirmwareType.BitcoinOnly;
        }
        else if (feat.fw_vendor === 'Trezor') {
            this.firmwareType = types_1.FirmwareType.Regular;
        }
        else if (this.getMode() !== 'bootloader') {
            this.firmwareType =
                feat.capabilities &&
                    feat.capabilities.length > 0 &&
                    !feat.capabilities.includes('Capability_Bitcoin_like')
                    ? types_1.FirmwareType.BitcoinOnly
                    : types_1.FirmwareType.Regular;
        }
        const deviceInfo = (_d = models_1.models[feat.internal_model]) !== null && _d !== void 0 ? _d : {
            name: `Unknown ${feat.internal_model}`,
            colors: {},
        };
        this.name = deviceInfo.name;
        if (feat === null || feat === void 0 ? void 0 : feat.unit_color) {
            const deviceUnitColor = feat.unit_color.toString();
            if (deviceUnitColor in deviceInfo.colors) {
                this.color = deviceInfo.colors[deviceUnitColor];
            }
        }
    }
    isUnacquired() {
        return this.features === undefined;
    }
    disconnect() {
        _log.debug('Disconnect cleanup');
        this.transportSession = null;
        this.interruptionFromUser(constants_1.ERRORS.TypedError('Device_Disconnected'));
        delete this.runPromise;
    }
    isBootloader() {
        return this.features && !!this.features.bootloader_mode;
    }
    isInitialized() {
        return this.features && !!this.features.initialized;
    }
    isSeedless() {
        return this.features && !!this.features.no_backup;
    }
    isInconsistent() {
        return this.inconsistent;
    }
    getVersion() {
        if (!this.features)
            return;
        return [
            this.features.major_version,
            this.features.minor_version,
            this.features.patch_version,
        ];
    }
    atLeast(versions) {
        const version = this.getVersion();
        if (!this.features || !version)
            return false;
        const modelVersion = typeof versions === 'string' ? versions : versions[this.features.major_version - 1];
        return utils_1.versionUtils.isNewerOrEqual(version, modelVersion);
    }
    isUsed() {
        return typeof this.originalDescriptor.session === 'string';
    }
    isUsedHere() {
        return this.isUsed() && this.originalDescriptor.session === this.transportSession;
    }
    isUsedElsewhere() {
        return this.isUsed() && !this.isUsedHere();
    }
    isRunning() {
        return !!this.runPromise;
    }
    isLoaded() {
        return this.loaded;
    }
    waitForFirstRun() {
        return this.firstRunPromise.promise;
    }
    getDevicePath() {
        return this.originalDescriptor.path;
    }
    isT1() {
        return this.features ? this.features.major_version === 1 : false;
    }
    hasUnexpectedMode(allow, require) {
        if (this.features) {
            if (this.isBootloader() && !allow.includes(events_1.UI.BOOTLOADER)) {
                return events_1.UI.BOOTLOADER;
            }
            if (!this.isInitialized() && !allow.includes(events_1.UI.INITIALIZE)) {
                return events_1.UI.INITIALIZE;
            }
            if (this.isSeedless() && !allow.includes(events_1.UI.SEEDLESS)) {
                return events_1.UI.SEEDLESS;
            }
            if (!this.isBootloader() && require.includes(events_1.UI.BOOTLOADER)) {
                return events_1.UI.NOT_IN_BOOTLOADER;
            }
        }
        return null;
    }
    updateDescriptor(descriptor) {
        this.originalDescriptor = {
            session: descriptor.session,
            path: descriptor.path,
            product: descriptor.product,
            type: descriptor.type,
        };
    }
    async dispose() {
        this.removeAllListeners();
        if (this.isUsedHere() && this.transportSession) {
            try {
                if (this.commands) {
                    await this.commands.cancel();
                }
                return this.transport.release({
                    session: this.transportSession,
                    path: this.originalDescriptor.path,
                    onClose: true,
                });
            }
            catch (err) {
            }
        }
    }
    getMode() {
        if (this.features.bootloader_mode)
            return 'bootloader';
        if (!this.features.initialized)
            return 'initialize';
        if (this.features.no_backup)
            return 'seedless';
        return 'normal';
    }
    toMessageObject() {
        var _a;
        if (this.unreadableError) {
            return {
                type: 'unreadable',
                path: this.originalDescriptor.path,
                error: this.unreadableError,
                label: 'Unreadable device',
                name: this.name,
            };
        }
        if (this.isUnacquired()) {
            return {
                type: 'unacquired',
                path: this.originalDescriptor.path,
                label: 'Unacquired device',
                name: this.name,
            };
        }
        const defaultLabel = 'My Trezor';
        const label = this.features.label === '' || !this.features.label ? defaultLabel : this.features.label;
        let status = this.isUsedElsewhere() ? 'occupied' : 'available';
        if (this.featuresNeedsReload)
            status = 'used';
        return {
            type: 'acquired',
            id: this.features.device_id,
            path: this.originalDescriptor.path,
            label,
            _state: this.getState(),
            state: (_a = this.getState()) === null || _a === void 0 ? void 0 : _a.staticSessionId,
            status,
            mode: this.getMode(),
            name: this.name,
            color: this.color,
            firmware: this.firmwareStatus,
            firmwareRelease: this.firmwareRelease,
            firmwareType: this.firmwareType,
            features: this.features,
            unavailableCapabilities: this.unavailableCapabilities,
            availableTranslations: this.availableTranslations,
            authenticityChecks: this.authenticityChecks,
        };
    }
    async legacyForceRelease() {
        if (this.isUsedHere()) {
            await this.acquire();
            await this.getFeatures();
            await this.release();
        }
    }
}
exports.Device = Device;
//# sourceMappingURL=Device.js.map