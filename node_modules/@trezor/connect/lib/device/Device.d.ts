import { Deferred, TypedEmitter } from '@trezor/utils';
import { TransportProtocol } from '@trezor/protocol';
import { DeviceCommands, PassphrasePromptResponse } from './DeviceCommands';
import { PROTO, NETWORK } from '../constants';
import { DEVICE, DeviceButtonRequestPayload } from '../events';
import { type Transport, type Descriptor } from '@trezor/transport';
import { Device as DeviceTyped, DeviceFirmwareStatus, DeviceState, Features, ReleaseInfo, UnavailableCapabilities, FirmwareType, VersionArray, KnownDevice } from '../types';
import { IStateStorage } from './StateStorage';
export type RunOptions = {
    skipFinalReload?: boolean;
    waiting?: boolean;
    onlyOneActivity?: boolean;
    cancelPopupRequest?: () => any;
    keepSession?: boolean;
    useCardanoDerivation?: boolean;
};
export declare const GET_FEATURES_TIMEOUT = 3000;
export declare const GET_FEATURES_TIMEOUT_REACT_NATIVE = 20000;
export interface DeviceEvents {
    [DEVICE.PIN]: (device: Device, b: PROTO.PinMatrixRequestType | undefined, callback: (err: any, pin: string) => void) => void;
    [DEVICE.WORD]: (device: Device, b: PROTO.WordRequestType, callback: (err: any, word: string) => void) => void;
    [DEVICE.PASSPHRASE]: (device: Device, callback: (response: PassphrasePromptResponse) => void) => void;
    [DEVICE.PASSPHRASE_ON_DEVICE]: () => void;
    [DEVICE.BUTTON]: (device: Device, payload: DeviceButtonRequestPayload) => void;
    [DEVICE.ACQUIRED]: () => void;
}
export declare class Device extends TypedEmitter<DeviceEvents> {
    transport: Transport;
    protocol: TransportProtocol;
    originalDescriptor: Descriptor;
    unreadableError?: string;
    firmwareStatus: DeviceFirmwareStatus;
    firmwareRelease?: ReleaseInfo | null;
    features: Features;
    featuresNeedsReload: boolean;
    private acquirePromise?;
    private releasePromise?;
    private runPromise?;
    private transportSession?;
    keepTransportSession: boolean;
    commands?: DeviceCommands;
    loaded: boolean;
    inconsistent: boolean;
    firstRunPromise: Deferred<boolean>;
    instance: number;
    private state;
    private stateStorage?;
    unavailableCapabilities: UnavailableCapabilities;
    networkTypeState: NETWORK.NetworkType[];
    firmwareType?: FirmwareType;
    name: string;
    color?: string;
    availableTranslations: string[];
    authenticityChecks: NonNullable<KnownDevice['authenticityChecks']>;
    private useCardanoDerivation;
    constructor(transport: Transport, descriptor: Descriptor);
    static fromDescriptor(transport: Transport, originalDescriptor: Descriptor): Device;
    static createUnacquired(transport: Transport, descriptor: Descriptor, unreadableError?: string): Device;
    acquire(): Promise<void>;
    release(): Promise<void>;
    cleanup(): Promise<void>;
    run(fn?: () => Promise<void>, options?: RunOptions): Promise<void>;
    override(error: Error): Promise<void>;
    interruptionFromUser(error: Error): Promise<void>;
    interruptionFromOutside(): void;
    _runInner<X>(fn: (() => Promise<X>) | undefined, options: RunOptions): Promise<void>;
    getCommands(): DeviceCommands;
    setInstance(instance?: number): void;
    getInstance(): number;
    getState(): DeviceState | undefined;
    setState(state?: Partial<DeviceState>): void;
    validateState(preauthorized?: boolean): Promise<`${string}@${string}:${number}` | undefined>;
    initialize(useCardanoDerivation: boolean): Promise<void>;
    initStorage(storage: IStateStorage): void;
    getFeatures(): Promise<void>;
    checkFirmwareRevision(): Promise<void>;
    changeLanguage({ language, binary, }: {
        language?: undefined;
        binary: ArrayBuffer;
    } | {
        language: string;
        binary?: undefined;
    }): Promise<{
        message: string;
    }>;
    private _uploadTranslationData;
    _updateFeatures(feat: Features): void;
    isUnacquired(): boolean;
    disconnect(): void;
    isBootloader(): boolean;
    isInitialized(): boolean;
    isSeedless(): boolean;
    isInconsistent(): boolean;
    getVersion(): VersionArray | undefined;
    atLeast(versions: string[] | string): boolean;
    isUsed(): boolean;
    isUsedHere(): boolean;
    isUsedElsewhere(): boolean;
    isRunning(): boolean;
    isLoaded(): boolean;
    waitForFirstRun(): Promise<boolean>;
    getDevicePath(): `${number}`;
    isT1(): boolean;
    hasUnexpectedMode(allow: string[], require: string[]): "ui-device_bootloader_mode" | "ui-device_not_in_bootloader_mode" | "ui-device_not_initialized" | "ui-device_seedless" | null;
    updateDescriptor(descriptor: Descriptor): void;
    dispose(): Promise<{
        success: false;
        error: "Network request failed";
    } | {
        success: false;
        error: "Wrong result type.";
    } | {
        success: false;
        error: "device disconnected during action";
    } | {
        success: false;
        error: "unexpected error";
    } | {
        success: false;
        error: "session not found";
    } | {
        success: false;
        error: "Aborted by timeout";
    } | {
        success: false;
        error: "Aborted by signal";
    } | {
        success: false;
        error: "This transport can not be used in this environment";
    } | {
        success: false;
        error: "device not found";
    } | {
        success: false;
        error: "Unable to open device";
    } | {
        success: false;
        error: "wrong previous session";
    } | import("@trezor/transport/lib/types").Success<void> | undefined>;
    getMode(): "normal" | "bootloader" | "initialize" | "seedless";
    toMessageObject(): DeviceTyped;
    legacyForceRelease(): Promise<void>;
}
//# sourceMappingURL=Device.d.ts.map