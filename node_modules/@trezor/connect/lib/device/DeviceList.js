"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DeviceList = exports.assertDeviceListConnected = void 0;
const utils_1 = require("@trezor/utils");
const transport_1 = require("@trezor/transport");
const constants_1 = require("../constants");
const events_1 = require("../events");
const Device_1 = require("./Device");
const transportInfo_1 = require("../data/transportInfo");
const debug_1 = require("../utils/debug");
const promiseUtils_1 = require("../utils/promiseUtils");
const _log = (0, debug_1.initLog)('DeviceList');
const createAuthPenaltyManager = (priority) => {
    const penalizedDevices = {};
    const get = () => 100 * priority +
        Object.keys(penalizedDevices).reduce((penalty, key) => Math.max(penalty, penalizedDevices[key]), 0);
    const add = (device) => {
        if (!device.isInitialized() || device.isBootloader() || !device.features.device_id)
            return;
        const deviceID = device.features.device_id;
        const penalty = penalizedDevices[deviceID] ? penalizedDevices[deviceID] + 500 : 2000;
        penalizedDevices[deviceID] = Math.min(penalty, 5000);
    };
    const remove = (device) => {
        if (!device.isInitialized() || device.isBootloader() || !device.features.device_id)
            return;
        const deviceID = device.features.device_id;
        delete penalizedDevices[deviceID];
    };
    const clear = () => Object.keys(penalizedDevices).forEach(key => delete penalizedDevices[key]);
    return { get, add, remove, clear };
};
const assertDeviceListConnected = deviceList => {
    if (!deviceList.isConnected())
        throw constants_1.ERRORS.TypedError('Transport_Missing');
};
exports.assertDeviceListConnected = assertDeviceListConnected;
class DeviceList extends utils_1.TypedEmitter {
    isConnected() {
        return !!this.transport;
    }
    pendingConnection() {
        return this.initPromise;
    }
    constructor({ messages, priority, debug }) {
        super();
        this.devices = {};
        this.creatingDevicesDescriptors = {};
        const transportLogger = (0, debug_1.initLog)('@trezor/transport', debug);
        const abortController = new AbortController();
        this.authPenaltyManager = createAuthPenaltyManager(priority);
        this.transportCommonArgs = {
            messages,
            logger: transportLogger,
            signal: abortController.signal,
        };
        this.transports = [
            new transport_1.BridgeTransport({
                latestVersion: (0, transportInfo_1.getBridgeInfo)().version.join('.'),
                ...this.transportCommonArgs,
            }),
        ];
    }
    createTransport(transportType) {
        const { transportCommonArgs } = this;
        if (typeof transportType === 'string') {
            switch (transportType) {
                case 'WebUsbTransport':
                    return new transport_1.WebUsbTransport(transportCommonArgs);
                case 'NodeUsbTransport':
                    return new transport_1.NodeUsbTransport(transportCommonArgs);
                case 'BridgeTransport':
                    return new transport_1.BridgeTransport({
                        latestVersion: (0, transportInfo_1.getBridgeInfo)().version.join('.'),
                        ...transportCommonArgs,
                    });
                case 'UdpTransport':
                    return new transport_1.UdpTransport(transportCommonArgs);
            }
        }
        else if (typeof transportType === 'function' && 'prototype' in transportType) {
            const transportInstance = new transportType(transportCommonArgs);
            if ((0, transport_1.isTransportInstance)(transportInstance)) {
                return transportInstance;
            }
        }
        else if ((0, transport_1.isTransportInstance)(transportType)) {
            if (!transportType.getMessage()) {
                transportType.updateMessages(transportCommonArgs.messages);
            }
            return transportType;
        }
        throw constants_1.ERRORS.TypedError('Runtime', `DeviceList.init: transports[] of unexpected type: ${transportType}`);
    }
    setTransports(transports) {
        const transportTypes = (transports === null || transports === void 0 ? void 0 : transports.length) ? transports : ['BridgeTransport'];
        this.transports = transportTypes.map(this.createTransport.bind(this));
    }
    onTransportUpdate(diff, transport) {
        diff.forEach(async ({ descriptor, ...category }) => {
            var _a;
            const path = descriptor.path.toString();
            const device = this.devices[path];
            this.creatingDevicesDescriptors[path] = descriptor;
            switch (category.type) {
                case 'disconnected':
                    if (!device)
                        break;
                    device.disconnect();
                    delete this.devices[path];
                    this.emit(events_1.DEVICE.DISCONNECT, device.toMessageObject());
                    break;
                case 'connected':
                    const penalty = this.authPenaltyManager.get();
                    if (penalty) {
                        await (0, promiseUtils_1.resolveAfter)(501 + penalty, null).promise;
                    }
                    if (this.creatingDevicesDescriptors[path].session == null) {
                        await this._createAndSaveDevice(descriptor, transport);
                    }
                    else {
                        const device = this._createUnacquiredDevice(descriptor, transport);
                        this.devices[path] = device;
                        this.emit(events_1.DEVICE.CONNECT_UNACQUIRED, device.toMessageObject());
                    }
                    break;
                case 'acquired':
                    if (!device)
                        break;
                    if (category.subtype === 'elsewhere') {
                        device.featuresNeedsReload = true;
                        device.interruptionFromOutside();
                    }
                    _log.debug('Event', events_1.DEVICE.CHANGED, device.toMessageObject());
                    this.emit(events_1.DEVICE.CHANGED, device.toMessageObject());
                    _log.debug('Event', events_1.DEVICE.ACQUIRED, device.toMessageObject());
                    this.emit(events_1.DEVICE.ACQUIRED, device.toMessageObject());
                    break;
                case 'released':
                    if (!device)
                        break;
                    const methodStillRunning = !((_a = device.commands) === null || _a === void 0 ? void 0 : _a.isDisposed());
                    if (methodStillRunning) {
                        device.keepTransportSession = false;
                    }
                    _log.debug('Event', events_1.DEVICE.CHANGED, device.toMessageObject());
                    this.emit(events_1.DEVICE.CHANGED, device.toMessageObject());
                    _log.debug('Event', events_1.DEVICE.RELEASED, device.toMessageObject());
                    this.emit(events_1.DEVICE.RELEASED, device.toMessageObject());
                    if (category.subtype === 'elsewhere') {
                        await (0, promiseUtils_1.resolveAfter)(1000, null).promise;
                        if (!device.isUsed() && device.isUnacquired() && !device.isInconsistent()) {
                            _log.debug('Create device from unacquired', device.toMessageObject());
                            await this._createAndSaveDevice(descriptor, transport);
                        }
                    }
                    break;
            }
            device === null || device === void 0 ? void 0 : device.updateDescriptor(descriptor);
        });
    }
    init(initParams = {}) {
        if (!this.initPromise) {
            _log.debug('Initializing transports');
            this.initPromise = this.createInitPromise(initParams);
        }
        return this.initPromise;
    }
    createInitPromise(initParams) {
        return this.selectTransport(this.transports)
            .then(transport => this.initializeTransport(transport, initParams))
            .then(transport => {
            this.transport = transport;
            this.emit(transport_1.TRANSPORT.START, this.getTransportInfo());
            this.initPromise = undefined;
        })
            .catch(error => {
            this.cleanup();
            this.emit(transport_1.TRANSPORT.ERROR, error);
            this.initPromise = initParams.transportReconnect
                ? this.createReconnectPromise(initParams)
                : undefined;
        });
    }
    createReconnectPromise(initParams) {
        const { promise, reject } = (0, promiseUtils_1.resolveAfter)(1000, initParams);
        this.rejectPending = reject;
        return promise.then(this.createInitPromise.bind(this));
    }
    async selectTransport([transport, ...rest]) {
        const result = await transport.init();
        if (result.success)
            return transport;
        else if (rest.length)
            return this.selectTransport(rest);
        else
            throw new Error(result.error);
    }
    async initializeTransport(transport, initParams) {
        transport.on(transport_1.TRANSPORT.UPDATE, diff => this.onTransportUpdate(diff, transport));
        transport.on(transport_1.TRANSPORT.ERROR, error => {
            this.cleanup();
            this.emit(transport_1.TRANSPORT.ERROR, error);
            if (initParams.transportReconnect) {
                this.initPromise = this.createReconnectPromise(initParams);
            }
        });
        const enumerateResult = await transport.enumerate();
        if (!enumerateResult.success) {
            throw new Error(enumerateResult.error);
        }
        const descriptors = enumerateResult.payload;
        transport.handleDescriptorsChange(descriptors);
        transport.listen();
        const awaitedDevices = descriptors.length - Object.keys(this.devices).length;
        if (awaitedDevices > 0 && initParams.pendingTransportEvent) {
            await this.waitForDevices(awaitedDevices, 10000);
        }
        return transport;
    }
    waitForDevices(deviceCount, autoResolveMs) {
        const { promise, resolve, reject } = (0, utils_1.createDeferred)();
        let transportStartPending = deviceCount;
        const autoResolveTransportEventTimeout = setTimeout(resolve, autoResolveMs);
        this.rejectPending = reject;
        const onDeviceConnect = () => {
            transportStartPending--;
            if (transportStartPending === 0) {
                resolve();
            }
        };
        this.on(events_1.DEVICE.CONNECT, onDeviceConnect);
        this.on(events_1.DEVICE.CONNECT_UNACQUIRED, onDeviceConnect);
        return promise.finally(() => {
            this.rejectPending = undefined;
            clearTimeout(autoResolveTransportEventTimeout);
            this.off(events_1.DEVICE.CONNECT, onDeviceConnect);
            this.off(events_1.DEVICE.CONNECT_UNACQUIRED, onDeviceConnect);
        });
    }
    async _createAndSaveDevice(descriptor, transport) {
        _log.debug('Creating Device', descriptor);
        await this.handle(descriptor, transport);
    }
    _createUnacquiredDevice(descriptor, transport) {
        _log.debug('Creating Unacquired Device', descriptor);
        const device = Device_1.Device.createUnacquired(transport, descriptor);
        device.once(events_1.DEVICE.ACQUIRED, () => {
            this.emit(events_1.DEVICE.CONNECT, device.toMessageObject());
        });
        return device;
    }
    _createUnreadableDevice(descriptor, transport, unreadableError) {
        _log.debug('Creating Unreadable Device', descriptor, unreadableError);
        return Device_1.Device.createUnacquired(transport, descriptor, unreadableError);
    }
    getDevice(path) {
        return this.devices[path];
    }
    getFirstDevicePath() {
        return this.asArray()[0].path;
    }
    asArray() {
        return this.allDevices().map(device => device.toMessageObject());
    }
    allDevices() {
        return Object.keys(this.devices).map(key => this.devices[key]);
    }
    length() {
        return this.asArray().length;
    }
    transportType() {
        return this.transport.name;
    }
    getTransportInfo() {
        return {
            type: this.transportType(),
            version: this.transport.version,
            outdated: this.transport.isOutdated,
        };
    }
    dispose() {
        this.removeAllListeners();
        return this.cleanup();
    }
    async cleanup() {
        var _a;
        const { transport } = this;
        const devices = this.allDevices();
        this.transport = undefined;
        this.authPenaltyManager.clear();
        Object.keys(this.devices).forEach(key => delete this.devices[key]);
        (_a = this.rejectPending) === null || _a === void 0 ? void 0 : _a.call(this, new Error('Disposed'));
        devices.forEach(device => {
            this.emit(events_1.DEVICE.DISCONNECT, device.toMessageObject());
        });
        await Promise.all(devices.map(device => device.dispose()));
        transport === null || transport === void 0 ? void 0 : transport.stop();
    }
    async enumerate(transport = this.transport) {
        const res = await transport.enumerate();
        if (!res.success) {
            return;
        }
        res.payload.forEach(d => {
            if (this.devices[d.path]) {
                this.devices[d.path].updateDescriptor(d);
            }
        });
    }
    addAuthPenalty(device) {
        return this.authPenaltyManager.add(device);
    }
    removeAuthPenalty(device) {
        return this.authPenaltyManager.remove(device);
    }
    async handle(descriptor, transport) {
        var _a;
        const path = descriptor.path.toString();
        try {
            await this._takeAndCreateDevice(descriptor, transport);
        }
        catch (error) {
            _log.debug('Cannot create device', error);
            if (error.code === 'Device_NotFound' ||
                error.message === transport_1.TRANSPORT_ERROR.DEVICE_NOT_FOUND ||
                error.message === transport_1.TRANSPORT_ERROR.DEVICE_DISCONNECTED_DURING_ACTION ||
                error.message === transport_1.TRANSPORT_ERROR.UNEXPECTED_ERROR ||
                error.message === transport_1.TRANSPORT_ERROR.DESCRIPTOR_NOT_FOUND ||
                error.message === transport_1.TRANSPORT_ERROR.HTTP_ERROR) {
                delete this.devices[path];
            }
            else if (error.message === transport_1.TRANSPORT_ERROR.SESSION_WRONG_PREVIOUS) {
                this.enumerate(transport);
                this._handleUsedElsewhere(descriptor, transport);
            }
            else if (error.message === transport_1.TRANSPORT_ERROR.INTERFACE_UNABLE_TO_OPEN_DEVICE ||
                ((_a = error.message) === null || _a === void 0 ? void 0 : _a.indexOf(constants_1.ERRORS.LIBUSB_ERROR_MESSAGE)) >= 0 ||
                error.code === 'Device_InitializeFailed') {
                const device = this._createUnreadableDevice(this.creatingDevicesDescriptors[path], transport, error.message);
                this.devices[path] = device;
                this.emit(events_1.DEVICE.CONNECT_UNACQUIRED, device.toMessageObject());
            }
            else if (error.code === 'Device_UsedElsewhere') {
                this._handleUsedElsewhere(descriptor, transport);
            }
            else {
                await (0, promiseUtils_1.resolveAfter)(501, null).promise;
                await this.handle(descriptor, transport);
            }
        }
    }
    async _takeAndCreateDevice(descriptor, transport) {
        const device = Device_1.Device.fromDescriptor(transport, descriptor);
        const path = descriptor.path.toString();
        this.devices[path] = device;
        const promise = device.run();
        await promise;
        this.emit(events_1.DEVICE.CONNECT, device.toMessageObject());
    }
    _handleUsedElsewhere(descriptor, transport) {
        const path = descriptor.path.toString();
        const device = this._createUnacquiredDevice(this.creatingDevicesDescriptors[path], transport);
        this.devices[path] = device;
        this.emit(events_1.DEVICE.CONNECT_UNACQUIRED, device.toMessageObject());
    }
}
exports.DeviceList = DeviceList;
//# sourceMappingURL=DeviceList.js.map