"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const crypto_1 = require("crypto");
const AbstractMethod_1 = require("../core/AbstractMethod");
const firmware_1 = require("./firmware");
const firmwareInfo_1 = require("../data/firmwareInfo");
const constants_1 = require("../constants");
const types_1 = require("../types");
const paramsValidator_1 = require("./common/paramsValidator");
class CheckFirmwareAuthenticity extends AbstractMethod_1.AbstractMethod {
    init() {
        this.useEmptyPassphrase = true;
        this.requiredPermissions = ['management'];
        this.useDeviceState = false;
        const { payload } = this;
        (0, paramsValidator_1.validateParams)(payload, [{ name: 'baseUrl', type: 'string' }]);
        this.params = { baseUrl: payload.baseUrl };
    }
    async run() {
        var _a, _b;
        const { device } = this;
        if (!device.firmwareRelease) {
            throw constants_1.ERRORS.TypedError('Runtime', 'device.firmwareRelease is not set');
        }
        const btcOnly = device.firmwareType === types_1.FirmwareType.BitcoinOnly;
        try {
            const fw = await (0, firmware_1.getBinary)({
                releases: (0, firmwareInfo_1.getReleases)((_a = device.features) === null || _a === void 0 ? void 0 : _a.internal_model),
                baseUrl: (_b = this.params.baseUrl) !== null && _b !== void 0 ? _b : 'https://data.trezor.io',
                version: device.getVersion(),
                btcOnly,
            });
            if (!fw) {
                throw constants_1.ERRORS.TypedError('Runtime', 'checkFirmwareAuthenticity: firmware binary not found');
            }
            const { hash: expectedFirmwareHash, challenge } = (0, firmware_1.calculateFirmwareHash)(device.features.major_version, (0, firmware_1.stripFwHeaders)(fw), (0, crypto_1.randomBytes)(32));
            const result = await this.device
                .getCommands()
                .typedCall('GetFirmwareHash', 'FirmwareHash', {
                challenge,
            });
            const { message } = result;
            const { hash: actualFirmwareHash } = message;
            return {
                expectedFirmwareHash,
                actualFirmwareHash,
                valid: actualFirmwareHash === expectedFirmwareHash,
            };
        }
        catch (e) {
            throw constants_1.ERRORS.TypedError('Runtime', `${e}`);
        }
    }
}
exports.default = CheckFirmwareAuthenticity;
//# sourceMappingURL=checkFirmwareAuthenticity.js.map